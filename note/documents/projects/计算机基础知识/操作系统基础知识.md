# 操作系统

## 1 硬件结构

### 1.1 32位CPU和64位CPU的区别是什么？

    两者的主要区别在于一次能够计算多少字节的数据：

> 32位CPU一次能够计算4字节
> 
> 64位CPU一次能够计算8字节

    上面的32位和64位通常称为CPU的位宽，比如对于32位CPU，一个位宽就是4字节。对于64位的CPU一个位宽就是8字节。CPU的位宽越大，一次可以计算的数值就越大，比如32位CPU能够计算的最大整数是`429497295`。

### 1.2 CPU寄存器是什么？

    CPU的寄存器的主要作用是存储CPU计算时所需要的数据，既然有了内存，为什么还需要寄存器呢？因为从内存读取寄存器的数据是非常慢的，内存举例CPU是非常远的，而寄存器就在CPU里面，紧挨着控制单元和逻辑运算但愿，计算速度会更快。

    常见的CPU寄存器有三类：

- 通用寄存器：用来存放需要运算的数据

- 程序计数器：用来存储CPU要执行下一条指令**所在的内存地址**，注意不是存储下一条指令，此时指令还在内存当中，程序计数器只是存储了下一条指令的地址。

- 指令寄存器：用来存放程序计数器指向的指令，也就是指令本身，在指令被执行完成之前，指令都存放在这里。

### 1.3 线路位宽和CPU位宽

    CPU和内存以及其他设备之间的通信都是通过总线来进行的，总线可以分为三种：

- 地址总线：用于指定CPU将要操作的内存地址

- 数据总线：用于读写内存的数据

- 控制总线，用于发送和接受信号，比如中断、设备复位等信号，CPU收到信号之后自然进行相应，这时候也需要控制总线

    当CPU要读写内存数据的时候，一般需要两个总线：

1. 先通过地址总线来指定内存的地址

2. 再通过数据总线来传输数据

    数据是通过数据总线来进行传输的，实际上是通过操作电压来传输的，低电压表示0，高电压表示1.

    比如对于高低高这样的信号，其实就是101二进制数据，十进制表示5，如果只有一条线路，就意味着每次只能传递1bit的数据，那么传输3词才能完成，效率很低。

    当我们在从内存中读取数据的时候，首先要知道内存的地址，才能去内存中获取相应的数据，如果采用上述的传输方式，效率是非常低的。

    为了提高数据传输的效率，线路的位宽最好一次就能访问到所有的内存地址。CPU想要操作内存地址的话就需要地址总线，如果地址总线只有一条，那么每次只能表示0或者1.这两种情况CPU只能一次操作两个内存地址，如果CPU想要操作4G的内存，那么就需要32条地址总线，因为**2^32 = 4G**。这就是线路位宽的概念。

    CPU的位宽最好不要小于线路位宽，因为这样可以保证CPU可以一次性读取到地址总线传来的所有数据，所以32位的CPU最好和32位宽的宽路进行搭配，因为32位CPU一次最多只能操作32位宽的地址总线和数据总线。

> 32位CPU最大只能操作4GB内存，就算装了8GB的内存条也是没用的。
> 
> 64位CPU的寻址范围很大，理论上最大的寻址空间为`2^64`
> 
> 对于32位操作系统，低3G是用户空间，高1G是内核空间

### 1.4 软中断

    在计算机中，中断是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求。中断是一种异步的事件处理机制，可以提高系统的并发处理能力。

    操作系统收到中断请求，会打断其他进程的运行，所以中断请求的响应程序，也就是中断处理程序，要尽可能快的执行完，这样可以减少对正常进程运行调度的影响。

    而且中断程序在响应中断的时候，可能还会**临时关闭中断**，这意味着如果当前中断处理程序没有执行完之前，系统中其他的中断请求都无法被响应，也就是说中断有可能会丢失，所以中断处理程序应该短且快。

#### 1.4.1 什么是软中断

    前面我们提到了，中断请求的处理程序应该短且快，这样才能减少对正常进程运行调度的影响，而且中断处理程序可能会暂时关闭中断，这时候入伏哦中断处理程序执行时间过长的话，可能还未执行完中断处理程序之前，会丢失当其他设备的中断请求。

    Linux为了解决处理程序执行时间过长和中断丢失的问题，将中断过程分成了两个阶段，分别是**上半部分和下半部分**

- 上半部分用来快速处理中断，一般会暂时关闭中断请求，主要分则处理跟硬件紧密相关或者时间敏感的事情

- 下半部分用来延迟处理上半部分未完成的工作，一般以内核线程的方式运行

    举一个网卡接受数据包的例子。

> 网卡在收到网络包之后，会通过硬件中断通知内核有新的数据产生了，于是内核就会调用对应的中断处理程序来响应该事件，这个事件的处理也是会分成上半部分和下半部分。
> 
> 上部分要做到快速处理，所以只要把网卡的数据读到内存当中，然后更新一下硬件寄存器的状态，比如把状态更新为表示表示数据已经读到内存中的状态值。
> 
> 接着，内核会出发一个软中断，把一些处理比较耗时并且复杂的事情，交给软中断处理程序去做，也就是中断的下半部分，主要是需要从内存中找到网络数据，再按照网络协议栈对网络数据进行逐层解析和处理，最后把数据送给应用程序。

    所以中断处理程序上半部分和下半部分可以理解为：

- 上半部分直接处理硬件请求，也就是硬中断，主要是负责耗时比较短的工作，特点是快速执行

- 下半部分由内核触发，也就是软中断，主要是负责上半部分未完成的工作，通常都是耗时比较久的事情，特点是延迟执行

    还有一个区别，硬中断（上半部）是会打断CPU正在执行的任务，然后立即执行中断处理程序，而软中断（下半部）是以内核线程的方式执行的，并且每一个CPU都对应一个软中断的内核线程，名字通常为[ksoftirqd/CPU编号]。


























